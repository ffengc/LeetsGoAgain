

# Top interview 150

**Site:** [https://leetcode.com/studyplan/top-interview-150/](https://leetcode.com/studyplan/top-interview-150/)



## 88. Merge Sorted Array

https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150

这题很简单，两个升序数组的合并

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        assert(nums1.size() == m + n);
        std::vector<int> res;
        int i1 = 0;
        int i2 = 0;
        while(i1 < m && i2 < n)
            if(nums1[i1] < nums2[i2])
                res.push_back(nums1[i1++]);
            else
                res.push_back(nums2[i2++]);
        while(i1 < m)
            res.push_back(nums1[i1++]);
        while(i2 < n)
            res.push_back(nums2[i2++]);
        res.swap(nums1);
    }
};
```

## 27. Remove Element

https://leetcode.com/problems/remove-element/?envType=study-plan-v2&envId=top-interview-150

删除指定元素，我用双指针替换即可。

中途有一些情况需要细细考虑到才行。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // use two pointers
        if(nums.size() == 0) return 0;
        int left = 0;
        int right = nums.size() - 1;
        while(left < right) {
            if(nums[left] != val) left++;
            else if(nums[left] == val) std::swap(nums[left], nums[right--]);
        }
        assert(left >= right);
        if(nums[left] == val) return left; // special case
        return left + 1;
    }
};
```

## 26. Remove Duplicates from Sorted Array

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150

删除重复元素，留下一个

也是用双指针控制即可

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return 1;
        // use two pointers
        int slow = 0;
        int fast = 0;
        while(fast < nums.size()) {
            if(nums[fast] == nums[slow]) fast++;
            if(fast >= nums.size()) break;
            if(nums[fast] != nums[slow]) {
                nums[++slow] = nums[fast++];
            }
        }
        return slow + 1;
    }
};
```

## 80. Remove Duplicates from Sorted Array II

https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150


删除重复元素，至多有两个。

其实肯定是要用双指针，但是调不出来。damn

```cpp
// 我的版本，未通过
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return 1;
        if(nums.size() == 2) return 2;
        // use two pointers
        // can reuse the codes in the last question(#26)
        int slow = 0;
        int fast = 0;
        while(fast < nums.size()) {
            int fast_step = 0;
            while(fast < nums.size() && nums[fast] == nums[slow]) {
                fast++;
                fast_step++;
            }
            if(fast >= nums.size()) {
                if(fast_step >= 2) {
                    nums[slow + 1] = nums[slow];
                    return slow + 2;
                }
                else return slow + 1;
                break;
            }
            if(nums[fast] != nums[slow]) {
                if(fast_step >= 2) {
                    slow += 2;
                    nums[slow] = nums[fast];
                } else {
                    nums[++slow] = nums[fast];
                }
            }
        }
        return slow + 1; 
    }
};
```


题解:

因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，我们定义两个指针 `slow` 和 `fast` 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 `nums[fast]` 表示待检查的第一个元素，`nums[slow−1]` 为上一个应该被保留的元素所移动到的指定位置。

因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 `nums[slow−2]` 是否和当前待检查元素 `nums[fast]` 相同。当且仅当 `nums[slow−2]=nums[fast]` 时，当前待检查元素 `nums[fast]` 不应该被保留（因为此时必然有 `nums[slow−2]=nums[slow−1]=nums[fast]`）。最后，`slow` 即为处理好的数组的长度。

特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。

> 作者：力扣官方题解
链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solutions/702644/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n <= 2) {
            return n;
        }
        int slow = 2, fast = 2;
        while (fast < n) {
            if (nums[slow - 2] != nums[fast]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
};
```

## 169. Majority Element

https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150

这题就是找到数组中出现次数大于 n/2 的数字。

**Follow-up:** Could you solve the problem in linear time and in O(1) space?

难点其实是他这个 Follow-up 的要求。

如果用哈希，是很简单的，不赘述，时间复杂度是 $O(n)$，空间是 $O(n)$

如果是排序，也很简单：排序之后，数组最中间的位置，就一定是要找的数字，因为他数量超过 n/2。时间是 $O(n\log n)$, 空间是 $O(1)$。

这里介绍题解里面比较特别的一种方法，可以做到 Follow-up 的要求。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        while (true) {
            int candidate = nums[rand() % nums.size()];
            int count = 0;
            for (int num : nums)
                if (num == candidate)
                    ++count;
            if (count > nums.size() / 2)
                return candidate;
        }
        return -1;
    }
};
```

复杂度分析

时间复杂度：理论上最坏情况下的时间复杂度为 O(∞)，因为如果我们的运气很差，这个算法会一直找不到众数，随机挑选无穷多次，所以最坏时间复杂度是没有上限的。然而，运行的期望时间是线性的。为了更简单地分析，先说服你自己：由于众数占据 超过 数组一半的位置，期望的随机次数会小于众数占据数组恰好一半的情况。因此，我们可以计算随机的期望次数（下标为 prob 为原问题，mod 为众数恰好占据数组一半数目的问题）：

$$
\begin{aligned}
E\left(\text { iters }_{\text {prob }}\right) & \leq E\left(\text { iters }_{\text {mod }}\right) \\
& =\lim _{n \rightarrow \infty} \sum_{i=1}^{n} i \cdot \frac{1}{2^{i}} \\
& =2
\end{aligned}
$$

 
计算方法为：当众数恰好占据数组的一半时，第一次随机我们有 $1/2$ 的概率找到众数，如果没有找到，则第二次随机时，包含上一次我们有 $1/4$ 的概率找到众数，以此类推。因此期望的次数为 $i \cdot 1/2^i$的和，可以计算出这个和为 2，说明期望的随机次数是常数。每一次随机后，我们需要 $O(n)$ 的时间判断这个数是否为众数，因此期望的时间复杂度为 $O(n)$。

空间复杂度：$O(1)$。随机方法只需要常数级别的额外空间。

> 作者：力扣官方题解
链接：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

然后中文版官网的题解还有两种很有意思的算法，分治法和Boyer-Moore投票算法：[https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/](https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/)


## 189. Rotate Array

https://leetcode.com/problems/rotate-array/description/?envType=study-plan-v2&envId=top-interview-150

Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.

这个题目还是用之前学的，三次反转的方法。

```cpp
class Solution {
public:
    void reverse(std::vector<int>::iterator begin, std::vector<int>::iterator end) {
        // end is set out of range
        end--;
        while(begin < end)
            std::swap(*begin++, *end--);
    }
    void rotate(vector<int>& nums, int k) {
        if(k > nums.size()) k = k % nums.size();
        reverse(nums.begin(), nums.end() - k);
        reverse(nums.end() - k, nums.end());
        reverse(nums.begin(), nums.end());
    }
};
```

顺利通过。

## 121. Best Time to Buy and Sell Stock

经典股票问题。

还记得 Carl 教的，股票问题：把状态处理好即可！

You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

这个是一买一卖的。

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        auto dp = std::vector<std::vector<int>>(2, std::vector<int>(prices.size(), 0));
        // first row: have stock
        // second row: donot have stock
        // dp[][]: the cash i have
        dp[0][0] = -prices[0];
        dp[1][0] = 0;
        for(int j = 1; j < prices.size(); ++j) {
            dp[0][j] = std::max(dp[0][j-1], -prices[j]);
            dp[1][j] = std::max(dp[1][j-1], dp[0][j-1] + prices[j]);
        }
        return dp[1][prices.size() - 1];
    }
};
```

顺利通过。

## 122. Best Time to Buy and Sell Stock II

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150

You are given an integer array prices where prices[i] is the price of a given stock on the ith day.

On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can sell and buy the stock multiple times on the same day, ensuring you never hold more than one share of the stock.

Find and return the maximum profit you can achieve.

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        auto dp = std::vector<std::vector<int>>(2, std::vector<int>(prices.size(), 0));
        // first row: have stock
        // second row: donot have stock
        // dp[][]: the cash i have
        dp[0][0] = -prices[0];
        dp[1][0] = 0;
        for(int j = 1; j < prices.size(); ++j) {
            dp[0][j] = std::max(dp[0][j-1], dp[1][j-1] - prices[j]); // modify here
            dp[1][j] = std::max(dp[1][j-1], dp[0][j-1] + prices[j]);
        }
        return dp[1][prices.size() - 1];
    }
};
```
很简单，改这里即可。

## ***55. Jump Game

https://leetcode.com/problems/jump-game/description/?envType=study-plan-v2&envId=top-interview-150

You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return true if you can reach the last index, or false otherwise.

这题还挺有意思的：

用大白话来翻译你的解释，其实就是把数组看成一串断掉的独木桥，你从终点往回修路：
- Valid Spot（有效点）：就是已经被证明“只要站在这里，就一定能走到终点”的位置。
- loop_cnt（索命距离）：就是当前位置距离最近的那个“有效点”有多远。
- 判定逻辑：如果当前的跳力 nums[i] 够得着最近的“有效点”，那当前位置 i 也就变成了一个新的“有效点”，后面的路就不用愁了，loop_cnt 重置为 1（看前一个点能不能跳到 i）。

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        if(nums.size() == 1) return true;
        int loop_cnt = 1;
        for(int i = nums.size() - 2; i >= 0; i--) {
            // nums.size() - 2 is the index to make a last jump
            // can nums.size() - 2 reach the dest? see if nums[i] > loop_cnt
            // loop_cnt refers to the distance to the closest valid spot
            // valid spot: a spot that can find a way to dest
            if(nums[i] >= loop_cnt) {
                loop_cnt = 1; // continue to 1
                continue;
            }
            loop_cnt++;
        }
        return nums[0] >= loop_cnt;
    }
};
```

这题本质是一个贪心。