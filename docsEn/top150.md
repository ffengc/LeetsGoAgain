

# Top interview 150

**Site:** [https://leetcode.com/studyplan/top-interview-150/](https://leetcode.com/studyplan/top-interview-150/)



## 88. Merge Sorted Array

https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150

这题很简单，两个升序数组的合并

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        assert(nums1.size() == m + n);
        std::vector<int> res;
        int i1 = 0;
        int i2 = 0;
        while(i1 < m && i2 < n)
            if(nums1[i1] < nums2[i2])
                res.push_back(nums1[i1++]);
            else
                res.push_back(nums2[i2++]);
        while(i1 < m)
            res.push_back(nums1[i1++]);
        while(i2 < n)
            res.push_back(nums2[i2++]);
        res.swap(nums1);
    }
};
```

## 27. Remove Element

https://leetcode.com/problems/remove-element/?envType=study-plan-v2&envId=top-interview-150

删除指定元素，我用双指针替换即可。

中途有一些情况需要细细考虑到才行。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        // use two pointers
        if(nums.size() == 0) return 0;
        int left = 0;
        int right = nums.size() - 1;
        while(left < right) {
            if(nums[left] != val) left++;
            else if(nums[left] == val) std::swap(nums[left], nums[right--]);
        }
        assert(left >= right);
        if(nums[left] == val) return left; // special case
        return left + 1;
    }
};
```

## 26. Remove Duplicates from Sorted Array

https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150

删除重复元素，留下一个

也是用双指针控制即可

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return 1;
        // use two pointers
        int slow = 0;
        int fast = 0;
        while(fast < nums.size()) {
            if(nums[fast] == nums[slow]) fast++;
            if(fast >= nums.size()) break;
            if(nums[fast] != nums[slow]) {
                nums[++slow] = nums[fast++];
            }
        }
        return slow + 1;
    }
};
```

## 80. Remove Duplicates from Sorted Array II

https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150


删除重复元素，至多有两个。

其实肯定是要用双指针，但是调不出来。damn

```cpp
// 我的版本，未通过
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        if(nums.size() == 1) return 1;
        if(nums.size() == 2) return 2;
        // use two pointers
        // can reuse the codes in the last question(#26)
        int slow = 0;
        int fast = 0;
        while(fast < nums.size()) {
            int fast_step = 0;
            while(fast < nums.size() && nums[fast] == nums[slow]) {
                fast++;
                fast_step++;
            }
            if(fast >= nums.size()) {
                if(fast_step >= 2) {
                    nums[slow + 1] = nums[slow];
                    return slow + 2;
                }
                else return slow + 1;
                break;
            }
            if(nums[fast] != nums[slow]) {
                if(fast_step >= 2) {
                    slow += 2;
                    nums[slow] = nums[fast];
                } else {
                    nums[++slow] = nums[fast];
                }
            }
        }
        return slow + 1; 
    }
};
```


题解:

因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，遍历数组检查每一个元素是否应该被保留，如果应该被保留，就将其移动到指定位置。具体地，我们定义两个指针 `slow` 和 `fast` 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度，快指针表示已经检查过的数组的长度，即 `nums[fast]` 表示待检查的第一个元素，`nums[slow−1]` 为上一个应该被保留的元素所移动到的指定位置。

因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 `nums[slow−2]` 是否和当前待检查元素 `nums[fast]` 相同。当且仅当 `nums[slow−2]=nums[fast]` 时，当前待检查元素 `nums[fast]` 不应该被保留（因为此时必然有 `nums[slow−2]=nums[slow−1]=nums[fast]`）。最后，`slow` 即为处理好的数组的长度。

特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。

> 作者：力扣官方题解
链接：https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/solutions/702644/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n <= 2) {
            return n;
        }
        int slow = 2, fast = 2;
        while (fast < n) {
            if (nums[slow - 2] != nums[fast]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
};
```

## 169. Majority Element

https://leetcode.com/problems/majority-element/description/?envType=study-plan-v2&envId=top-interview-150

这题就是找到数组中出现次数大于 n/2 的数字。

**Follow-up:** Could you solve the problem in linear time and in O(1) space?

难点其实是他这个 Follow-up 的要求。

如果用哈希，是很简单的，不赘述，时间复杂度是 $O(n)$，空间是 $O(n)$

如果是排序，也很简单：排序之后，数组最中间的位置，就一定是要找的数字，因为他数量超过 n/2。时间是 $O(n\log n)$, 空间是 $O(1)$。

这里介绍题解里面比较特别的一种方法，可以做到 Follow-up 的要求。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        while (true) {
            int candidate = nums[rand() % nums.size()];
            int count = 0;
            for (int num : nums)
                if (num == candidate)
                    ++count;
            if (count > nums.size() / 2)
                return candidate;
        }
        return -1;
    }
};
```

复杂度分析

时间复杂度：理论上最坏情况下的时间复杂度为 O(∞)，因为如果我们的运气很差，这个算法会一直找不到众数，随机挑选无穷多次，所以最坏时间复杂度是没有上限的。然而，运行的期望时间是线性的。为了更简单地分析，先说服你自己：由于众数占据 超过 数组一半的位置，期望的随机次数会小于众数占据数组恰好一半的情况。因此，我们可以计算随机的期望次数（下标为 prob 为原问题，mod 为众数恰好占据数组一半数目的问题）：

$$
\begin{aligned}
E\left(\text { iters }_{\text {prob }}\right) & \leq E\left(\text { iters }_{\text {mod }}\right) \\
& =\lim _{n \rightarrow \infty} \sum_{i=1}^{n} i \cdot \frac{1}{2^{i}} \\
& =2
\end{aligned}
$$

 
计算方法为：当众数恰好占据数组的一半时，第一次随机我们有 $1/2$ 的概率找到众数，如果没有找到，则第二次随机时，包含上一次我们有 $1/4$ 的概率找到众数，以此类推。因此期望的次数为 $i \cdot 1/2^i$的和，可以计算出这个和为 2，说明期望的随机次数是常数。每一次随机后，我们需要 $O(n)$ 的时间判断这个数是否为众数，因此期望的时间复杂度为 $O(n)$。

空间复杂度：$O(1)$。随机方法只需要常数级别的额外空间。

> 作者：力扣官方题解
链接：https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

然后中文版官网的题解还有两种很有意思的算法，分治法和Boyer-Moore投票算法：[https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/](https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/)